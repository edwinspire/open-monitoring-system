{"version":3,"file":"Executor.js","sourceRoot":"","sources":["../../../../src/lib/executors/Executor.ts"],"names":[],"mappings":"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","sourcesContent":["import * as chai from 'chai';\nimport { deepMixin, duplicate } from '@dojo/core/lang';\nimport { Handle } from '@dojo/core/interfaces';\nimport Task, { isThenable, State } from '@dojo/core/async/Task';\nimport global from '@dojo/shim/global';\n\nimport Suite from '../Suite';\nimport Test from '../Test';\nimport ErrorFormatter, { ErrorFormatOptions } from '../common/ErrorFormatter';\nimport {\n\tBenchmarkConfig,\n\tConfig,\n\tPluginDescriptor,\n\tReporterDescriptor\n} from '../common/config';\nimport { normalizePathEnding } from '../common/path';\nimport { isTask, processOption, pullFromArray } from '../common/util';\nimport Reporter from '../reporters/Reporter';\nimport {\n\tgetInterface as getObjectInterface,\n\tObjectInterface\n} from '../interfaces/object';\nimport {\n\tgetInterface as getTddInterface,\n\tTddInterface\n} from '../interfaces/tdd';\nimport {\n\tgetInterface as getBddInterface,\n\tBddInterface\n} from '../interfaces/bdd';\nimport {\n\tgetInterface as getBenchmarkInterface,\n\tBenchmarkInterface\n} from '../interfaces/benchmark';\nimport { InternError, RuntimeEnvironment } from '../types';\nimport * as console from '../common/console';\n\n/**\n * This interface represents the core functionality of an Executor\n */\nexport interface Executor {\n\treadonly config: Config;\n\treadonly suites: Suite[];\n\n\taddSuite(factory: (parentSuite: Suite) => void): void;\n\n\tconfigure(options: { [key: string]: any }): void;\n\n\temit<T extends NoDataEvents>(eventName: T): Task<void>;\n\temit<T extends keyof Events>(eventName: T, data: Events[T]): Task<void>;\n\n\tformatError(error: Error, options?: ErrorFormatOptions): string;\n\n\tlog(...args: any[]): Task<void>;\n\n\ton<T extends keyof Events>(\n\t\teventName: T,\n\t\tlistener: Listener<Events[T]>\n\t): Handle;\n\ton(listener: Listener<{ name: string; data?: any }>): Handle;\n}\n\n/**\n * This is the base executor class.\n *\n * Executors are the main driver of the testing process. An instance of Executor\n * is assigned to the `intern` global.\n */\nexport default abstract class BaseExecutor<\n\tE extends Events,\n\tC extends Config,\n\tP extends Plugins\n> implements Executor {\n\tprotected _config: C;\n\tprotected _rootSuite: Suite;\n\tprotected _events: InternEvent<E>[];\n\tprotected _errorFormatter: ErrorFormatter | undefined;\n\tprotected _hasSuiteErrors = false;\n\tprotected _hasTestErrors = false;\n\tprotected _hasEmittedErrors = false;\n\tprotected _loader!: Loader;\n\tprotected _loaderOptions: any;\n\tprotected _loaderInit: Promise<Loader> | undefined;\n\tprotected _loadingPlugins: { name: string; init: Task<void> }[];\n\tprotected _loadingPluginOptions: any | undefined;\n\tprotected _listeners: { [event: string]: Listener<any>[] };\n\tprotected _plugins: { [name: string]: any };\n\tprotected _reporters: Reporter[];\n\tprotected _runTask: Task<void> | undefined;\n\tprotected _reportersInitialized: boolean;\n\n\tconstructor(options?: { [key in keyof C]?: any }) {\n\t\tthis._config = <C>{\n\t\t\tbail: false,\n\t\t\tbaseline: false,\n\t\t\tbenchmark: false,\n\t\t\tbrowser: {\n\t\t\t\tplugins: <PluginDescriptor[]>[],\n\t\t\t\treporters: <ReporterDescriptor[]>[],\n\t\t\t\tsuites: <string[]>[]\n\t\t\t},\n\t\t\tcoverageVariable: '__coverage__',\n\t\t\tdebug: false,\n\t\t\tdefaultTimeout: 30000,\n\t\t\tfilterErrorStack: false,\n\t\t\tgrep: new RegExp(''),\n\t\t\tloader: { script: 'default' },\n\t\t\tname: 'intern',\n\t\t\tnode: {\n\t\t\t\tplugins: <PluginDescriptor[]>[],\n\t\t\t\treporters: <ReporterDescriptor[]>[],\n\t\t\t\tsuites: <string[]>[]\n\t\t\t},\n\t\t\tplugins: <PluginDescriptor[]>[],\n\t\t\treporters: <ReporterDescriptor[]>[],\n\t\t\tsessionId: '',\n\t\t\tsuites: <string[]>[]\n\t\t};\n\n\t\tthis._reportersInitialized = false;\n\t\tthis._events = [];\n\t\tthis._listeners = {};\n\t\tthis._reporters = [];\n\t\tthis._plugins = {};\n\t\tthis._loadingPlugins = [];\n\n\t\tthis.registerInterface('object', getObjectInterface(this));\n\t\tthis.registerInterface('tdd', getTddInterface(this));\n\t\tthis.registerInterface('bdd', getBddInterface(this));\n\t\tthis.registerInterface('benchmark', getBenchmarkInterface(this));\n\n\t\tthis.registerPlugin('chai', () => chai);\n\n\t\tif (options) {\n\t\t\tthis.configure(options);\n\t\t}\n\n\t\tthis._rootSuite = new Suite({ executor: this });\n\n\t\t// This is the first suiteEnd listener. When the root unit test suite\n\t\t// ends, it will emit a coverage message before any other suiteEnd\n\t\t// listeners are called.\n\t\tthis.on('suiteEnd', suite => {\n\t\t\tif (suite.error) {\n\t\t\t\tthis._hasSuiteErrors = true;\n\t\t\t}\n\t\t\tif (!suite.hasParent && !suite.sessionId) {\n\t\t\t\treturn this._emitCoverage('unit tests');\n\t\t\t}\n\t\t});\n\n\t\tthis.on('testEnd', test => {\n\t\t\tif (test.error) {\n\t\t\t\tthis._hasTestErrors = true;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get the current enviroment\n\t */\n\tabstract get environment(): RuntimeEnvironment;\n\n\t/**\n\t * The resolved configuration for this executor.\n\t */\n\tget config() {\n\t\treturn this._config;\n\t}\n\n\t/**\n\t * The root suites managed by this executor\n\t */\n\tget suites() {\n\t\treturn [this._rootSuite];\n\t}\n\n\t/**\n\t * Format an error, normalizing the stack trace and resolving source map\n\t * references\n\t */\n\tformatError(error: Error, options?: ErrorFormatOptions): string {\n\t\tif (!this._errorFormatter) {\n\t\t\tthis._errorFormatter = new ErrorFormatter(this);\n\t\t}\n\t\treturn this._errorFormatter.format(error, options);\n\t}\n\n\t/**\n\t * Load a script or scripts. This is a convenience method for loading and\n\t * evaluating simple scripts, not necessarily modules. If multiple script\n\t * paths are provided, scripts will be loaded sequentially in the order\n\t * given.\n\t *\n\t * @param script a path to a script\n\t */\n\tabstract loadScript(script: string | string[]): Task<void>;\n\n\t/**\n\t * Add a suite to the set of suites that will be run when `run` is called.\n\t *\n\t * The suite is added by calling a factory function. The use of a factory\n\t * allows for distinct instances of a given suite to be create when an\n\t * executor has multiple root suites.\n\t *\n\t * ```js\n\t * intern.addSuite(parent => {\n\t *     const suite = new Suite({\n\t *         name: 'create new',\n\t *         tests: [\n\t *             new Test({\n\t *                 name: 'new test',\n\t *                 test: () => assert.doesNotThrow(() => new Component())\n\t *             })\n\t *         ]\n\t *     });\n\t *     parent.add(suite);\n\t * });\n\t * ```\n\t *\n\t * @param factory A function that will add a new Suite object to a given\n\t * parent suite.\n\t */\n\taddSuite(factory: (parentSuite: Suite) => void) {\n\t\tfactory(this._rootSuite);\n\t}\n\n\t/**\n\t * Configure the executor with an object containing\n\t * [[lib/executors/Executor.Config]] properties.\n\t */\n\tconfigure(options: { [key in keyof C]?: any }) {\n\t\tObject.keys(options).forEach(option => {\n\t\t\tconst key = <keyof C>option;\n\t\t\tthis._processOption(key, options[key]);\n\t\t});\n\t}\n\n\t/**\n\t * Emit an event to all registered listeners.\n\t *\n\t * Event listeners may execute async code, and a failing handler (one that\n\t * rejects or throws an error) will cause the emit to fail.\n\t *\n\t * @param eventName the name of the event to emit\n\t * @param data a data object whose type is event-dependent\n\t * @returns a Task that resolves when all listeners have processed the event\n\t */\n\temit<T extends NoDataEvents>(eventName: T): Task<void>;\n\temit<T extends keyof E>(eventName: T, data: E[T]): Task<void>;\n\temit<T extends keyof E>(eventName: T, data?: E[T]) {\n\t\tif (eventName === 'error') {\n\t\t\tthis._hasEmittedErrors = true;\n\t\t}\n\n\t\t// Ignore log messages if not in debug mode\n\t\tif (eventName === 'log' && !this.config.debug) {\n\t\t\treturn Task.resolve();\n\t\t}\n\n\t\t// If reporters haven't been loaded yet, queue the event for later\n\t\tif (!this._reportersInitialized) {\n\t\t\tthis._events.push({ eventName, data });\n\t\t\treturn Task.resolve();\n\t\t}\n\n\t\t// Handle the case when an error is emitted by an event listener. If\n\t\t// we're not already handling an error, emit a new error event. If we\n\t\t// are, then assume the error handler is broken and just console.error\n\t\t// the error.\n\t\tconst handleListenerError = (error: Error) => {\n\t\t\tif (eventName === 'error') {\n\t\t\t\tconsole.error(this.formatError(error));\n\t\t\t} else {\n\t\t\t\treturn this.emit('error', error);\n\t\t\t}\n\t\t};\n\n\t\tlet error: InternError | undefined;\n\t\tif (eventName === 'error') {\n\t\t\terror = <any>data;\n\t\t}\n\n\t\t// If this is an error event, mark the error as 'reported'\n\t\tconst handleErrorEvent = () => {\n\t\t\tif (error) {\n\t\t\t\terror.reported = true;\n\t\t\t}\n\t\t};\n\n\t\tlet notifications = Task.resolve();\n\t\tlet hasNotifications = false;\n\n\t\t// First, notify the listeners specifically listening for this event\n\t\tconst listeners = this._listeners[eventName];\n\t\tif (listeners && listeners.length > 0) {\n\t\t\thasNotifications = true;\n\t\t\tfor (const listener of listeners) {\n\t\t\t\tnotifications = notifications\n\t\t\t\t\t.then(() => Task.resolve(listener(data)))\n\t\t\t\t\t.then(handleErrorEvent)\n\t\t\t\t\t.catch(handleListenerError);\n\t\t\t}\n\t\t}\n\n\t\t// Next, notify 'star' listeners, which listen for all events\n\t\tconst starListeners = this._listeners['*'];\n\t\tif (starListeners && starListeners.length > 0) {\n\t\t\thasNotifications = true;\n\t\t\tconst starEvent = { name: eventName, data };\n\t\t\tfor (const listener of starListeners) {\n\t\t\t\tnotifications = notifications\n\t\t\t\t\t.then(() => Task.resolve(listener(starEvent)))\n\t\t\t\t\t.then(handleErrorEvent)\n\t\t\t\t\t.catch(handleListenerError);\n\t\t\t}\n\t\t}\n\n\t\tif (!hasNotifications) {\n\t\t\t// If reporters haven't been loaded yet, cache the event\n\t\t\tif (error) {\n\t\t\t\t// Report errors, warnings, deprecation messages when no\n\t\t\t\t// listeners are registered\n\t\t\t\tconsole.error(this.formatError(error));\n\t\t\t\terror.reported = true;\n\t\t\t} else if (eventName === 'warning') {\n\t\t\t\tconsole.warn(`WARNING: ${data}`);\n\t\t\t} else if (eventName === 'deprecated') {\n\t\t\t\tconst message = data!;\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`WARNING: ${message.original} is deprecated, use ${\n\t\t\t\t\t\tmessage.replacement\n\t\t\t\t\t} instead.`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn Task.resolve();\n\t\t}\n\n\t\treturn notifications;\n\t}\n\n\t/**\n\t * Get a registered interface plugin.\n\t *\n\t * This method calls `getPlugin` behind the scenes.\n\t *\n\t * @param name the name of the interface\n\t * @returns the interface, which may be an object or a callable function, or\n\t * undefined if no such interface was registered.\n\t */\n\tgetInterface(name: 'object'): ObjectInterface;\n\tgetInterface(name: 'tdd'): TddInterface;\n\tgetInterface(name: 'bdd'): BddInterface;\n\tgetInterface(name: 'benchmark'): BenchmarkInterface;\n\tgetInterface(name: string): any {\n\t\treturn this.getPlugin(`interface.${name}`);\n\t}\n\n\t/**\n\t * Get any resources registered by a particular plugin.\n\t *\n\t * @param type the type of plugin (e.g., 'interface' or 'reporter')\n\t * @param name the name of the plugin\n\t * @returns the resource registered for the given plugin name, or undefined\n\t * if no such plugin was registered.\n\t */\n\tgetPlugin<Y extends keyof P>(type: Y, name: string): P[Y];\n\tgetPlugin(name: 'chai'): typeof chai;\n\tgetPlugin(name: 'interface.object'): ObjectInterface;\n\tgetPlugin(name: 'interface.tdd'): TddInterface;\n\tgetPlugin(name: 'interface.bdd'): BddInterface;\n\tgetPlugin(name: 'interface.benchmark'): BenchmarkInterface;\n\tgetPlugin<T>(name: string): T;\n\tgetPlugin<T>(type: string, name?: string): T {\n\t\tconst pluginName =\n\t\t\ttypeof name === 'undefined' ? type : `${type}.${name}`;\n\n\t\tif (!(pluginName in this._plugins)) {\n\t\t\tthrow new Error(\n\t\t\t\t`A plugin named \"${pluginName}\" has not been registered`\n\t\t\t);\n\t\t}\n\n\t\treturn <T>this._plugins[pluginName];\n\t}\n\n\t/**\n\t * This is a convenience method for emitting log events.\n\t *\n\t * When debug mode is enabled, this method emits 'log' events using `emit`.\n\t * Otherwise it does nothing.\n\t *\n\t * @param args A list of arguments that will be stringified and combined\n\t * into a space-separated message.\n\t * @returns a Task that resolves when all listeners have finished processing\n\t * the event.\n\t */\n\tlog(...args: any[]) {\n\t\tif (this.config.debug) {\n\t\t\tconst message = args\n\t\t\t\t.map(arg => {\n\t\t\t\t\tconst type = typeof arg;\n\t\t\t\t\tif (type === 'string') {\n\t\t\t\t\t\treturn arg;\n\t\t\t\t\t}\n\t\t\t\t\tif (type === 'function' || arg instanceof RegExp) {\n\t\t\t\t\t\treturn arg.toString();\n\t\t\t\t\t}\n\t\t\t\t\tif (arg instanceof Error) {\n\t\t\t\t\t\targ = {\n\t\t\t\t\t\t\tname: arg.name,\n\t\t\t\t\t\t\tmessage: arg.message,\n\t\t\t\t\t\t\tstack: arg.stack\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn JSON.stringify(arg);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treturn arg.toString();\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.join(' ');\n\t\t\treturn this.emit('log', message);\n\t\t} else {\n\t\t\treturn Task.resolve();\n\t\t}\n\t}\n\n\t/**\n\t * Add a listener for a test event.\n\t *\n\t * ```js\n\t * intern.on('error', error => {\n\t *     console.log('An error occurred:', error);\n\t * });\n\t * ```\n\t *\n\t * A listener can be notified of all events by registering for the '*'\n\t * event, or by calling on with only a callback:\n\t *\n\t * ```js\n\t * intern.on(event => {\n\t *     console.log(`An ${event.name} event occurred:`, event.data);\n\t * });\n\t * ```\n\t * Note that some events are executor-specific. For example, the\n\t * [[lib/executors/Browser]] executor will never emit a tunnelStop\n\t * message.\n\t *\n\t * @param eventName the [[lib/executors/Executor.Events|event]] to listen\n\t * for\n\t * @param listener a callback that accepts a single data parameter; it may\n\t * return a PromiseLike object if it needs to perform async actions\n\t * @returns a handle with a `destroy` method that can be used to stop\n\t * listening\n\t */\n\ton<T extends keyof E>(eventName: T, listener: Listener<E[T]>): Handle;\n\ton(listener: Listener<{ name: string; data?: any }>): Handle;\n\ton<T extends keyof E>(\n\t\teventName: T | Listener<any>,\n\t\tlistener?: Listener<E[T]>\n\t) {\n\t\tlet _eventName: T;\n\t\tif (typeof listener === 'undefined') {\n\t\t\tlistener = <Listener<any>>eventName;\n\t\t\t_eventName = <T>'*';\n\t\t} else {\n\t\t\t_eventName = <T>eventName;\n\t\t}\n\t\tlet listeners = this._listeners[_eventName];\n\t\tif (!listeners) {\n\t\t\tlisteners = this._listeners[_eventName] = [];\n\t\t}\n\n\t\tif (listeners.indexOf(listener) === -1) {\n\t\t\tlisteners.push(listener);\n\t\t}\n\n\t\tconst handle: Handle = {\n\t\t\tdestroy(this: any) {\n\t\t\t\tthis.destroy = function() {};\n\t\t\t\tpullFromArray(listeners, listener);\n\t\t\t}\n\t\t};\n\t\treturn handle;\n\t}\n\n\t/**\n\t * Register an interface plugin\n\t *\n\t * This is a convenience method for registering test interfaces. This method\n\t * calls [[lib/executors/Executor.Executor.registerPlugin]] behind the\n\t * scenes using the name `interface.${name}`.\n\t */\n\tregisterInterface(name: string, iface: any) {\n\t\tthis.registerPlugin(`interface.${name}`, () => iface);\n\t}\n\n\t/**\n\t * Register a module loader.\n\t *\n\t * This method sets the loader script that will be used to load plugins and\n\t * suites. The callback should accept an options object and return a\n\t * function that can load modules.\n\t *\n\t * ```js\n\t * intern.registerLoader(options: any => {\n\t *     // Register loader can return a Promise if it needs to load something\n\t *     // itself\n\t *     return intern.loadScript('some/loader.js').then(() => {\n\t *         loader.config(options);\n\t *         // Return a function that takes a list of modules and returns a\n\t *         // Promise that resolves when they've been loaded.\n\t *         return (modules: string[]) => {\n\t *             return loader.load(modules);\n\t *         });\n\t *     });\n\t * });\n\t * ```\n\t *\n\t * @param init a loader initialzation callback that should return a loader\n\t * function, or a Promise that resolves to a loader function\n\t */\n\tregisterLoader(init: LoaderInit) {\n\t\tconst options = this._loaderOptions\n\t\t\t? duplicate(this._loaderOptions)\n\t\t\t: {};\n\t\tthis._loaderInit = Promise.resolve(init(options));\n\t}\n\n\t/**\n\t * Register a plugin.\n\t *\n\t * Plugins are resources that are loaded at the beginning of the testing\n\t * process, after the loader but before any suites are registered. The\n\t * callback may return a Promise if the plugin needs to do some asynchronous\n\t * initialization. If the plugin is being loaded via the\n\t * [[lib/executors/Executor.Config.plugins|config.plugins]]\n\t * property, it's init callback will be passed any configured options. The\n\t * resolved return value of the callback will be returned by\n\t * [[lib/executors/Executor.Executor.getPlugin]].\n\t *\n\t * ```js\n\t * intern.registerPlugin('foo', (options: any) => {\n\t *     return {\n\t *         doSomething() {\n\t *             // ...\n\t *         },\n\t *         doSomethingElse() {\n\t *             // ...\n\t *         }\n\t *     };\n\t * });\n\t * ```\n\t *\n\t * Code would use the plugin by calling getPlugin:\n\t *\n\t * ```js\n\t * const { doSomething, doSomethingElse } = intern.getPlugin('foo');\n\t * doSomething();\n\t * ```\n\t *\n\t * @param name the plugin name\n\t * @param init an initializer function that returns the plugin resource, or\n\t * a Promise that resolves to the resource\n\t */\n\tregisterPlugin<T extends keyof P>(\n\t\ttype: T,\n\t\tname: string,\n\t\tinit: PluginInitializer<P[T]>\n\t): void;\n\tregisterPlugin(name: string, init: PluginInitializer): void;\n\tregisterPlugin(\n\t\ttype: string,\n\t\tname: string | PluginInitializer,\n\t\tinit?: PluginInitializer\n\t) {\n\t\tconst pluginName =\n\t\t\ttypeof init === 'undefined' ? type : `${type}.${name}`;\n\t\tconst pluginInit =\n\t\t\ttypeof init === 'undefined' ? <PluginInitializer>name : init;\n\t\tconst options = this._loadingPluginOptions;\n\t\tconst result = options ? pluginInit(duplicate(options)) : pluginInit();\n\t\tif (isThenable(result)) {\n\t\t\t// If the result is thenable, push it on the loading queue\n\t\t\tthis._loadingPlugins.push({\n\t\t\t\tname: pluginName,\n\t\t\t\tinit: new Task<any>(\n\t\t\t\t\t(resolve, reject) =>\n\t\t\t\t\t\tresult.then(value => resolve(value), reject),\n\t\t\t\t\t() => {\n\t\t\t\t\t\tisTask(result) && result.cancel();\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t});\n\t\t} else {\n\t\t\t// If the result is not thenable, immediately add it to the plugins\n\t\t\t// list\n\t\t\tthis._assignPlugin(pluginName, result);\n\t\t}\n\t}\n\n\t/**\n\t * Register a reporter plugin\n\t *\n\t * This is a convenience method for registering reporter constructors. This\n\t * method calls [[lib/executors/Executor.Executor.registerPlugin]] behind\n\t * the scenes using the name `reporter.${name}`.\n\t *\n\t * @param name the reporter name\n\t * @param Ctor a reporter class constructor\n\t */\n\tregisterReporter(name: string, init: ReporterInitializer) {\n\t\tthis.registerPlugin('reporter', name, () => init);\n\t}\n\n\t/**\n\t * Run tests.\n\t *\n\t * This method sets up the environment for test execution, runs the tests,\n\t * and runs any finalization code afterwards.\n\t */\n\trun() {\n\t\t// Only allow the executor to be started once\n\t\tif (!this._runTask) {\n\t\t\tlet runError: Error;\n\n\t\t\ttry {\n\t\t\t\tthis._runTask = this._resolveConfig();\n\n\t\t\t\tif (this.config.showConfig) {\n\t\t\t\t\tthis._runTask = this._runTask\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\t// Emit the config as JSON deeply sorted by key\n\t\t\t\t\t\t\tconst sort = (value: any) => {\n\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\tvalue = value.map(sort).sort();\n\t\t\t\t\t\t\t\t} else if (typeof value === 'object') {\n\t\t\t\t\t\t\t\t\tconst newObj: { [key: string]: any } = {};\n\t\t\t\t\t\t\t\t\tObject.keys(value)\n\t\t\t\t\t\t\t\t\t\t.sort()\n\t\t\t\t\t\t\t\t\t\t.forEach(key => {\n\t\t\t\t\t\t\t\t\t\t\tnewObj[key] = sort(value[key]);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tvalue = newObj;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t\tJSON.stringify(sort(this.config), null, '    ')\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\t\t// Display resolution errors because reporters\n\t\t\t\t\t\t\t// haven't been installed yet\n\t\t\t\t\t\t\tconsole.error(this.formatError(error));\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tlet currentTask: Task<void>;\n\n\t\t\t\t\tthis._runTask = this._runTask\n\t\t\t\t\t\t.then(() => this._loadPlugins())\n\t\t\t\t\t\t.then(() => this._loadLoader())\n\t\t\t\t\t\t.then(() => this._loadPluginsWithLoader())\n\t\t\t\t\t\t.then(() => this._initReporters())\n\t\t\t\t\t\t.then(() => this._loadSuites())\n\t\t\t\t\t\t.then(() => this._beforeRun())\n\t\t\t\t\t\t.then((skipTests: boolean) => {\n\t\t\t\t\t\t\tif (skipTests) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Keep track of distinct tasks to allow them to be\n\t\t\t\t\t\t\t// cancelled\n\t\t\t\t\t\t\tlet outerTask: Task<void>;\n\t\t\t\t\t\t\tlet testingTask: Task<void>;\n\n\t\t\t\t\t\t\tcurrentTask = new Task<void>(\n\t\t\t\t\t\t\t\t(resolve, reject) => {\n\t\t\t\t\t\t\t\t\touterTask = this.emit('beforeRun')\n\t\t\t\t\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\t\t\t\t\treturn this.emit('runStart')\n\t\t\t\t\t\t\t\t\t\t\t\t.then(\n\t\t\t\t\t\t\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(testingTask = this._runTests())\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\t\t\t\t\t\t\t\trunError = error;\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.emit(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'error',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\terror\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t\t.finally(() =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.emit('runEnd')\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t.finally(() => this.emit('afterRun'))\n\t\t\t\t\t\t\t\t\t\t.then(resolve, reject);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\ttestingTask &&\n\t\t\t\t\t\t\t\t\t\ttestingTask.state === State.Pending\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\ttestingTask.cancel();\n\t\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\t\touterTask &&\n\t\t\t\t\t\t\t\t\t\touterTask.state === State.Pending\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\touterTask.cancel();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn currentTask;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\t\t// Ensure any queued events have been emitted.\n\t\t\t\t\t\t\tthis._reportersInitialized = true;\n\t\t\t\t\t\t\treturn this._drainEventQueue();\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.finally(() => this._afterRun())\n\t\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcurrentTask &&\n\t\t\t\t\t\t\t\tcurrentTask.state === State.Pending\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcurrentTask.cancel();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\t\treturn this.emit('error', error).finally(() => {\n\t\t\t\t\t\t\t\t// A runError has priority over any cleanup\n\t\t\t\t\t\t\t\t// errors, so rethrow one if it exists.\n\t\t\t\t\t\t\t\tthrow runError || error;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\t// If we didn't have any cleanup errors but a\n\t\t\t\t\t\t\t// runError was caught, throw it to reject the run\n\t\t\t\t\t\t\t// task\n\t\t\t\t\t\t\tif (runError) {\n\t\t\t\t\t\t\t\tthrow runError;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet message = '';\n\n\t\t\t\t\t\t\t// If there were no run errors but any suites had\n\t\t\t\t\t\t\t// errors, throw an error to reject the run task.\n\t\t\t\t\t\t\tif (this._hasSuiteErrors) {\n\t\t\t\t\t\t\t\tmessage =\n\t\t\t\t\t\t\t\t\t'One or more suite errors occurred during testing';\n\t\t\t\t\t\t\t} else if (this._hasTestErrors) {\n\t\t\t\t\t\t\t\t// If there were no run errors but any tests\n\t\t\t\t\t\t\t\t// failed, throw an error to reject the run\n\t\t\t\t\t\t\t\t// task.\n\t\t\t\t\t\t\t\tmessage = 'One or more tests failed';\n\t\t\t\t\t\t\t} else if (this._hasEmittedErrors) {\n\t\t\t\t\t\t\t\t// If there were no test or suite errors, but\n\t\t\t\t\t\t\t\t// *some* error was emitted, throw an error to\n\t\t\t\t\t\t\t\t// reject the run task.\n\t\t\t\t\t\t\t\tmessage = 'An error was emitted';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (message) {\n\t\t\t\t\t\t\t\tconst error: InternError = new Error(message);\n\t\t\t\t\t\t\t\t// Mark this error as reported so that the\n\t\t\t\t\t\t\t\t// runner script won't report it again.\n\t\t\t\t\t\t\t\terror.reported = true;\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis._runTask = this.emit('error', error).then(() => {\n\t\t\t\t\treturn Task.reject<void>(error);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn this._runTask;\n\t}\n\n\t/**\n\t * Code to execute after the main test run has finished to shut down the test system.\n\t */\n\tprotected _afterRun() {\n\t\treturn Task.resolve();\n\t}\n\n\t/**\n\t * Add a resolved plugin to the internal plugins list\n\t */\n\tprotected _assignPlugin(name: string, plugin: any) {\n\t\tif (name.indexOf('reporter.') === 0 && typeof plugin !== 'function') {\n\t\t\tthrow new Error('A reporter plugin must be a constructor');\n\t\t}\n\t\tthis._plugins[name] = plugin;\n\t}\n\n\t/**\n\t * Code to execute before the main test run has started to set up the test\n\t * system. This is where Executors can do any last-minute configuration\n\t * before the testing process begins.\n\t *\n\t * This method returns a Task that resolves to a boolean. A value of true\n\t * indicates that Intern should skip running tests and exit normally.\n\t */\n\tprotected _beforeRun() {\n\t\tconst { bail, grep, name, sessionId, defaultTimeout } = this.config;\n\t\tthis._rootSuite.bail = bail;\n\t\tthis._rootSuite.grep = grep;\n\t\tthis._rootSuite.name = name;\n\t\tthis._rootSuite.sessionId = sessionId;\n\t\tthis._rootSuite.timeout = defaultTimeout;\n\t\treturn Task.resolve(false);\n\t}\n\n\t/**\n\t * Instantiate any configured built-in reporters\n\t */\n\tprotected _initReporters() {\n\t\tconst config = this.config;\n\t\tconst envReporters = config[this.environment].reporters;\n\n\t\t// Take reporters from the base config that aren't also specified in an\n\t\t// environment config\n\t\tconst baseReporters = config.reporters.filter(reporter => {\n\t\t\treturn !envReporters.some(\n\t\t\t\tenvReporter => envReporter.name === reporter.name\n\t\t\t);\n\t\t});\n\n\t\tfor (const reporter of [...baseReporters, ...envReporters]) {\n\t\t\tconst initializer = this.getPlugin('reporter', reporter.name);\n\t\t\tif (!initializer) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`A reporter named ${reporter.name} hasn't been registered`\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (typeof initializer !== 'function') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`The reporter ${reporter.name} isn't a valid initializer`\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis._reporters.push(initializer(reporter.options));\n\t\t}\n\n\t\tthis._reportersInitialized = true;\n\n\t\treturn this._drainEventQueue();\n\t}\n\n\t/**\n\t * Emit any queued events. The event queue will be empty after this method\n\t * runs.\n\t */\n\tprotected _drainEventQueue() {\n\t\tlet task = Task.resolve();\n\t\twhile (this._events.length > 0) {\n\t\t\tconst event = this._events.shift()!;\n\t\t\ttask = task.then(() => {\n\t\t\t\treturn this.emit(event.eventName, event.data);\n\t\t\t});\n\t\t}\n\t\treturn task;\n\t}\n\n\tprotected _emitCoverage(source?: string) {\n\t\tconst coverage = global[this.config.coverageVariable];\n\t\tif (coverage) {\n\t\t\treturn this.emit('coverage', {\n\t\t\t\tcoverage,\n\t\t\t\tsource,\n\t\t\t\tsessionId: this.config.sessionId\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Load a loader\n\t */\n\tprotected _loadLoader() {\n\t\t// If registerLoader was already called, just wait for that loader to\n\t\t// initialize\n\t\tif (this._loaderInit) {\n\t\t\treturn this._loaderInit.then(loader => {\n\t\t\t\tthis._loader = loader;\n\t\t\t});\n\t\t} else {\n\t\t\t// No loader has been registered, so load the configured or default\n\t\t\t// one\n\t\t\tconst config = this.config;\n\t\t\tconst loader: { [key: string]: any } =\n\t\t\t\tconfig[this.environment].loader || config.loader;\n\n\t\t\tlet script = loader.script;\n\t\t\tswitch (script) {\n\t\t\t\tcase 'default':\n\t\t\t\tcase 'dojo':\n\t\t\t\tcase 'dojo2':\n\t\t\t\tcase 'esm':\n\t\t\t\tcase 'systemjs':\n\t\t\t\t\tscript = `${config.internPath}loaders/${script}.js`;\n\t\t\t}\n\n\t\t\tthis._loaderOptions = loader.options || {};\n\t\t\treturn this.loadScript(script)\n\t\t\t\t.then(() => {\n\t\t\t\t\tif (!this._loaderInit) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Loader script ${script} did not register a loader callback`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn this._loaderInit;\n\t\t\t\t})\n\t\t\t\t.then(loader => {\n\t\t\t\t\tthis._loader = loader;\n\t\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Load scripts in the `requires` list using an external loader, if\n\t * configured, or the platform's native loading mechanism\n\t */\n\tprotected _loadPluginsWithLoader() {\n\t\tconst scripts = [\n\t\t\t...this.config.plugins,\n\t\t\t...this.config[this.environment].plugins\n\t\t].filter(plugin => plugin.useLoader);\n\t\treturn this._loadScripts(scripts, script => this._loader([script]));\n\t}\n\n\t/**\n\t * Load scripts in the `plugins` list using the platform's native loading\n\t * mechanism\n\t */\n\tprotected _loadPlugins() {\n\t\tconst scripts = [\n\t\t\t...this.config.plugins,\n\t\t\t...this.config[this.environment].plugins\n\t\t].filter(plugin => !plugin.useLoader);\n\t\treturn this._loadScripts(scripts, script => this.loadScript(script));\n\t}\n\n\t/**\n\t * Load a list of scripts using a given loader. These will be loaded\n\t * sequentially in order.\n\t */\n\tprotected _loadScripts(\n\t\tscripts: PluginDescriptor[],\n\t\tloader: (script: string) => Promise<void>\n\t) {\n\t\treturn scripts\n\t\t\t.reduce((previous, script) => {\n\t\t\t\tif (typeof script === 'string') {\n\t\t\t\t\treturn previous.then(() => loader(script));\n\t\t\t\t} else {\n\t\t\t\t\treturn previous\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\tthis._loadingPluginOptions = script.options;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(() => loader(script.script))\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\tthis._loadingPluginOptions = undefined;\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, Task.resolve())\n\t\t\t.then(() => {\n\t\t\t\t// Wait for all plugin registrations, both configured ones and\n\t\t\t\t// any that were manually registered, to resolve\n\t\t\t\treturn Task.all(\n\t\t\t\t\tthis._loadingPlugins.map(entry => entry.init)\n\t\t\t\t).then(plugins => {\n\t\t\t\t\tplugins.forEach((plugin, index) => {\n\t\t\t\t\t\tthis._assignPlugin(\n\t\t\t\t\t\t\tthis._loadingPlugins[index].name,\n\t\t\t\t\t\t\tplugin\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t}\n\n\t/**\n\t * Load suites\n\t */\n\tprotected _loadSuites() {\n\t\t// _resolveSuites will expand all suites into <env>.suites for the\n\t\t// current env\n\t\tconst suites = this.config[this.environment].suites;\n\t\treturn Task.resolve(this._loader(suites!)).then(() => {\n\t\t\tthis.log('Loaded suites:', suites);\n\t\t});\n\t}\n\n\t/**\n\t * Process an option\n\t */\n\tprotected _processOption(key: keyof C, value: any) {\n\t\tprocessOption(key, value, this.config, this);\n\t}\n\n\t/**\n\t * Resolve the config object.\n\t */\n\tprotected _resolveConfig() {\n\t\tconst config = this.config;\n\n\t\tif (config.internPath != null) {\n\t\t\tconfig.internPath = normalizePathEnding(config.internPath);\n\t\t} else {\n\t\t\tconfig.internPath = '';\n\t\t}\n\n\t\tif (config.benchmark) {\n\t\t\tconfig.benchmarkConfig = deepMixin(\n\t\t\t\t<BenchmarkConfig>{\n\t\t\t\t\tmode: config.baseline ? 'baseline' : 'test',\n\t\t\t\t\tid: 'Benchmark',\n\t\t\t\t\tfilename: 'baseline.json',\n\t\t\t\t\tthresholds: {\n\t\t\t\t\t\twarn: { rme: 3, mean: 5 },\n\t\t\t\t\t\tfail: { rme: 6, mean: 10 }\n\t\t\t\t\t},\n\t\t\t\t\tverbosity: 0\n\t\t\t\t},\n\t\t\t\tconfig.benchmarkConfig || {}\n\t\t\t);\n\t\t}\n\n\t\treturn Task.resolve();\n\t}\n\n\t/**\n\t * Runs each of the root suites, limited to a certain number of suites at\n\t * the same time by `maxConcurrency`.\n\t */\n\tprotected _runTests() {\n\t\treturn this._rootSuite.run();\n\t}\n}\n\nexport { BenchmarkConfig, Config, PluginDescriptor, ReporterDescriptor };\n\nexport interface InternEvent<E extends Events> {\n\teventName: keyof E;\n\tdata?: any;\n}\n\nexport { Handle };\n\n/**\n * A generic event listener\n */\nexport interface Listener<T> {\n\t(arg: T): void | Promise<void>;\n}\n\n/**\n * The data accompanying a coverage event\n */\nexport interface CoverageMessage {\n\tsessionId?: string;\n\tsource?: string;\n\tcoverage: any;\n}\n\nexport interface DeprecationMessage {\n\toriginal: string;\n\treplacement?: string;\n\tmessage?: string;\n}\n\nexport interface ExecutorEvent {\n\tname: keyof Events;\n\tdata: any;\n}\n\n/**\n * Events that may be emitted by an Executor. Each event has at most one\n * associated message type. A few (e.g., afterRun) don't have messages.\n */\nexport interface Events {\n\t'*': ExecutorEvent;\n\n\t/** Emitted after the local executor has finished running suites */\n\tafterRun: void;\n\n\t/** Emitted before the local executor loads suites */\n\tbeforeRun: void;\n\n\t/** Coverage info has been gathered */\n\tcoverage: CoverageMessage;\n\n\t/** A deprecated method was called */\n\tdeprecated: DeprecationMessage;\n\n\t/** An unhandled error occurs */\n\terror: Error;\n\n\t/** A debug log event */\n\tlog: string;\n\n\t/** All tests have finished running */\n\trunEnd: void;\n\n\t/** Emitted just before tests start running  */\n\trunStart: void;\n\n\t/** A new suite has been added */\n\tsuiteAdd: Suite;\n\n\t/** A suite has fininshed running */\n\tsuiteEnd: Suite;\n\n\t/** A suite has started running */\n\tsuiteStart: Suite;\n\n\t/** A new test has been added */\n\ttestAdd: Test;\n\n\t/** A test has finished */\n\ttestEnd: Test;\n\n\t/** A test has started */\n\ttestStart: Test;\n\n\t/** A non-fatal error occurred */\n\twarning: string;\n}\n\n/** A list of event names that don't have associated data */\nexport type NoDataEvents = 'runStart' | 'runEnd' | 'beforeRun' | 'afterRun';\n\n/**\n * Known plugin types\n */\nexport interface Plugins {\n\treporter: ReporterInitializer;\n}\n\n/**\n * An async loader callback.\n */\nexport interface Loader {\n\t(modules: string[]): Promise<void>;\n}\n\n/**\n * A loader initialization function.\n */\nexport interface LoaderInit {\n\t(options: { [key: string]: any }): Promise<Loader> | Loader;\n}\n\nexport interface PluginInitializer<T extends any = any> {\n\t(options?: { [key: string]: any }): Task<T> | T;\n}\n\nexport interface ReporterInitializer {\n\t(options?: any): Reporter;\n}\n"]}