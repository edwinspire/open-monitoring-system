{"version":3,"file":"path.js","sourceRoot":"","sources":["../../../../src/lib/common/path.ts"],"names":[],"mappings":";;;;;;;;;;;IAGA,iBAAwB,IAAY;QACnC,IAAM,GAAG,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;QAC7B,IAAM,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACzC,KAAK,CAAC,GAAG,EAAE,CAAC;QACZ,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;YAC1C,OAAO,GAAG,CAAC;SACX;QACD,OAAO,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACxB,CAAC;IARD,0BAQC;IAKD;QAA2B,eAAkB;aAAlB,UAAkB,EAAlB,qBAAkB,EAAlB,IAAkB;YAAlB,0BAAkB;;QAC5C,OAAO,KAAK,CAAC,IAAI,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAf,CAAe,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC;IACzD,CAAC;IAFD,gCAEC;IAMD;QAAqB,eAAkB;aAAlB,UAAkB,EAAlB,qBAAkB,EAAlB,IAAkB;YAAlB,0BAAkB;;QACtC,IAAM,GAAG,GAAG,UAAU,eAAI,KAAK,CAAC,CAAC;QACjC,IAAM,WAAW,GAAG,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QACzC,IAAM,aAAa,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAEhD,IACC,aAAa,CAAC,MAAM,GAAG,CAAC;YACxB,aAAa,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,EAC7C;YACD,aAAa,CAAC,GAAG,EAAE,CAAC;SACpB;QAED,KAAmB,UAAoB,EAApB,KAAA,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,EAApB,cAAoB,EAApB,IAAoB;YAAlC,IAAM,IAAI,SAAA;YACd,KAAmB,UAAe,EAAf,KAAA,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAf,cAAe,EAAf,IAAe;gBAA7B,IAAM,IAAI,SAAA;gBACd,IAAI,IAAI,KAAK,IAAI,EAAE;oBAClB,aAAa,CAAC,GAAG,EAAE,CAAC;iBACpB;qBAAM,IAAI,IAAI,KAAK,GAAG,EAAE;oBACxB,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBACzB;aACD;SACD;QACD,OAAO,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAChC,CAAC;IAtBD,oBAsBC;IAKD,mBAA0B,IAAY;QACrC,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IACjC,CAAC;IAFD,8BAEC;IAKD,6BAAoC,IAAY,EAAE,OAAa;QAAb,wBAAA,EAAA,aAAa;QAC9D,IAAI,IAAI,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,OAAO,EAAE;YACjE,OAAO,KAAG,IAAI,GAAG,OAAS,CAAC;SAC3B;QACD,OAAO,IAAI,CAAC;IACb,CAAC;IALD,kDAKC","sourcesContent":["/**\n * Get the parent directory name of a path\n */\nexport function dirname(path: string) {\n\tconst sep = getPathSep(path);\n\tconst parts = normalize(path).split('/');\n\tparts.pop();\n\tif (parts.length === 1 && parts[0] === '') {\n\t\treturn sep;\n\t}\n\treturn parts.join(sep);\n}\n\n/**\n * Get the path separator used for a given set of paths.\n */\nexport function getPathSep(...paths: string[]) {\n\treturn paths.some(path => /\\\\/.test(path)) ? '\\\\' : '/';\n}\n\n/**\n * Join a set of paths, resolving any relative segments (. or ..) in subsequent\n * paths against the first path.\n */\nexport function join(...paths: string[]) {\n\tconst sep = getPathSep(...paths);\n\tconst normalPaths = paths.map(normalize);\n\tconst basePathParts = normalPaths[0].split('/');\n\n\tif (\n\t\tbasePathParts.length > 1 &&\n\t\tbasePathParts[basePathParts.length - 1] === ''\n\t) {\n\t\tbasePathParts.pop();\n\t}\n\n\tfor (const path of normalPaths.slice(1)) {\n\t\tfor (const part of path.split('/')) {\n\t\t\tif (part === '..') {\n\t\t\t\tbasePathParts.pop();\n\t\t\t} else if (part !== '.') {\n\t\t\t\tbasePathParts.push(part);\n\t\t\t}\n\t\t}\n\t}\n\treturn basePathParts.join(sep);\n}\n\n/**\n * Normalize a path, replacing any occurrences of '\\' with '/'\n */\nexport function normalize(path: string) {\n\treturn path.replace(/\\\\/g, '/');\n}\n\n/**\n * Normalize a path such that it ends with a path separator\n */\nexport function normalizePathEnding(path: string, pathSep = '/') {\n\tif (path && path.length > 0 && path[path.length - 1] !== pathSep) {\n\t\treturn `${path}${pathSep}`;\n\t}\n\treturn path;\n}\n"]}