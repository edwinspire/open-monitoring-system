{"version":3,"file":"Deferred.js","sourceRoot":"","sources":["../../../src/lib/Deferred.ts"],"names":[],"mappings":";;;;;;;;;;;IAAA;QAKC;YAAA,iBAMC;YALA,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO,CAAI,UAAC,OAAO,EAAE,MAAM;gBAC7C,KAAI,CAAC,SAAS,GAAG,OAAO,CAAC;gBACzB,KAAI,CAAC,SAAS,GAAG,MAAM,CAAC;YACzB,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,SAAS,EAAd,CAAc,EAAE,cAAM,OAAA,KAAI,CAAC,SAAS,EAAd,CAAc,CAAC,CAAC;QAC/D,CAAC;QAMD,2BAAQ,GAAR,UAAS,QAAkB;YAC1B,IAAM,GAAG,GAAG,IAAI,CAAC;YACjB,OAAO,IAAI,CAAC,aAAa,CAAC;gBAAoB,cAAc;qBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;oBAAd,yBAAc;;gBAC3D,IAAM,WAAW,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC/C,GAAG,CAAC,OAAO,EAAE,CAAC;gBACd,OAAO,WAAW,CAAC;YACpB,CAAC,CAAC,CAAC;QACJ,CAAC;QAKD,gCAAa,GAAb,UAAc,QAAkB;YAC/B,IAAM,GAAG,GAAG,IAAI,CAAC;YACjB,OAAO;gBAAoB,cAAc;qBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;oBAAd,yBAAc;;gBACxC,IAAI;oBACH,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;iBAClC;gBAAC,OAAO,KAAK,EAAE;oBACf,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBAClB;YACF,CAAC,CAAC;QACH,CAAC;QAED,0BAAO,GAAP,UAAQ,KAAS;YAChB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACvB,CAAC;QAED,yBAAM,GAAN,UAAO,KAAa;YACnB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACvB,CAAC;QAES,4BAAS,GAAnB;YACC,IAAI,CAAC,SAAS,GAAG,cAAO,CAAC,CAAC;YAC1B,IAAI,CAAC,SAAS,GAAG,cAAO,CAAC,CAAC;QAC3B,CAAC;QACF,eAAC;IAAD,CAAC,AApDD,IAoDC","sourcesContent":["export default class Deferred<T> {\n\tprivate _resolver!: (value?: T) => void;\n\tprivate _rejector!: (error?: Error) => void;\n\treadonly promise: Promise<T>;\n\n\tconstructor() {\n\t\tthis.promise = new Promise<T>((resolve, reject) => {\n\t\t\tthis._resolver = resolve;\n\t\t\tthis._rejector = reject;\n\t\t});\n\t\tthis.promise.then(() => this._finalize, () => this._finalize);\n\t}\n\n\t/**\n\t * Wraps any callback to resolve the deferred so long as the callback\n\t * executes without throwing any Errors.\n\t */\n\tcallback(callback: Function): any {\n\t\tconst dfd = this;\n\t\treturn this.rejectOnError(function(this: any, ...args: any[]) {\n\t\t\tconst returnValue = callback.apply(this, args);\n\t\t\tdfd.resolve();\n\t\t\treturn returnValue;\n\t\t});\n\t}\n\n\t/**\n\t * Wraps a callback to reject the deferred if the callback throws an Error.\n\t */\n\trejectOnError(callback: Function): any {\n\t\tconst dfd = this;\n\t\treturn function(this: any, ...args: any[]) {\n\t\t\ttry {\n\t\t\t\treturn callback.apply(this, args);\n\t\t\t} catch (error) {\n\t\t\t\tdfd.reject(error);\n\t\t\t}\n\t\t};\n\t}\n\n\tresolve(value?: T) {\n\t\tthis._resolver(value);\n\t}\n\n\treject(error?: Error) {\n\t\tthis._rejector(error);\n\t}\n\n\tprotected _finalize() {\n\t\tthis._resolver = () => {};\n\t\tthis._rejector = () => {};\n\t}\n}\n"]}