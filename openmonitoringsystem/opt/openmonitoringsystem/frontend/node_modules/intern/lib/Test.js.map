{"version":3,"file":"Test.js","sourceRoot":"","sources":["../../../src/lib/Test.ts"],"names":[],"mappings":"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","sourcesContent":["import Task, { isThenable, State } from '@dojo/core/async/Task';\nimport { mixin } from '@dojo/core/lang';\n\nimport { Executor } from './executors/Executor';\nimport Deferred from './Deferred';\nimport { InternError } from './types';\nimport { Remote } from './executors/Node';\nimport Suite from './Suite';\nimport { isTask } from './common/util';\n\n/**\n * A Test is a single unit or functional test.\n */\nexport default class Test implements TestProperties {\n\t/** The name of this test */\n\tname!: string;\n\n\t/** This test's parent Suite */\n\tparent!: Suite;\n\n\t/** If this test was skipped, this will contain a message indicating why */\n\tskipped: string | undefined;\n\n\t/** The test function that is run by this Test */\n\ttest!: TestFunction;\n\n\t/** The error that caused this Test to fail */\n\terror: InternError | undefined;\n\n\tprotected _hasPassed = false;\n\n\tprotected _isAsync = false;\n\n\tprotected _timeout: number | undefined;\n\n\tprotected _runTask: Task<any> | undefined;\n\n\tprotected _timeElapsed: number | undefined;\n\n\t// Use type 'any' because we may be running under Node (NodeJS.Timer) or a\n\t// browser (number)\n\tprotected _timer: any | undefined;\n\n\tprotected _usesRemote = false;\n\n\tconstructor(\n\t\toptions: TestOptions & { timeElapsed?: number; hasPassed?: boolean }\n\t) {\n\t\tif (!options.name || !options.test) {\n\t\t\tthrow new Error('A Test requires a name and a test function');\n\t\t}\n\n\t\t['timeElapsed', 'hasPassed'].forEach(property => {\n\t\t\tconst name = <keyof TestOptions>property;\n\t\t\tif (options[name] != null) {\n\t\t\t\t(<any>this)[`_${name}`] = options[name];\n\t\t\t}\n\t\t\tdelete options[name];\n\t\t});\n\n\t\tmixin(this, options);\n\t}\n\n\t/**\n\t * The executor running this test.\n\t */\n\tget executor(): Executor {\n\t\treturn this.parent && this.parent.executor;\n\t}\n\n\t/**\n\t * True if the test function completed successfully\n\t */\n\tget hasPassed() {\n\t\treturn this._hasPassed;\n\t}\n\n\t/**\n\t * The unique identifier of the test, assuming all combinations of suite +\n\t * test are unique.\n\t */\n\tget id() {\n\t\tlet name: string[] = [];\n\t\tlet suiteOrTest: Suite | Test = this;\n\n\t\tdo {\n\t\t\tsuiteOrTest.name != null && name.unshift(suiteOrTest.name);\n\t\t} while ((suiteOrTest = suiteOrTest.parent));\n\n\t\treturn name.join(' - ');\n\t}\n\n\t/**\n\t * If true, this Test's test function is async\n\t */\n\tget isAsync() {\n\t\treturn this._isAsync;\n\t}\n\n\t/**\n\t * The unique identifier of the test's parent.\n\t */\n\tget parentId() {\n\t\treturn this.parent.id;\n\t}\n\n\t/**\n\t * The WebDriver interface for driving a remote environment.\n\t * @see Suite#remote\n\t */\n\tget remote(): Remote {\n\t\tthis._usesRemote = true;\n\t\treturn this.parent.remote;\n\t}\n\n\t/**\n\t * An identifier for the test session this Test is running in.\n\t */\n\tget sessionId() {\n\t\treturn this.parent.sessionId;\n\t}\n\n\t/**\n\t * The number of milliseconds the test function took to complete.\n\t */\n\tget timeElapsed() {\n\t\treturn this._timeElapsed;\n\t}\n\n\t/**\n\t * The number of milliseconds this test can run before it will be canceled.\n\t */\n\tget timeout() {\n\t\tif (this._timeout != null) {\n\t\t\treturn this._timeout;\n\t\t}\n\t\tif (this.parent && this.parent.timeout != null) {\n\t\t\treturn this.parent.timeout;\n\t\t}\n\t\treturn 30000;\n\t}\n\n\tset timeout(value) {\n\t\tthis._timeout = value;\n\t}\n\n\t/**\n\t * This is a convenience function that generates and returns a special\n\t * [[lib/Deferred.Deferred]] that can be used for asynchronous testing.\n\t *\n\t * Once this method is called, a test is assumed to be asynchronous no\n\t * matter its return value (the generated Deferred's promise will always be\n\t * used as the implied return value if a promise is not returned by the test\n\t * function).\n\t *\n\t * The optional `numCallsUntilResolution` argument to `async` affects how the\n\t * callback method operates. By default, the Deferred is resolved (assuming\n\t * it hasnâ€™t already been rejected) the first time the function returned by\n\t * `callback` is called. If `numCallsUntilResolution` is set (it must be a\n\t * value > 0), the function returned by `callback` must be called\n\t * `numCallsUntilResolution` times before the Deferred resolves.\n\t *\n\t * @param timeout If provided, the amount of time to wait before rejecting\n\t * the test with a timeout error, in milliseconds.\n\t * @param numCallsUntilResolution The number of times that resolve needs to\n\t * be called before the Deferred is actually resolved.\n\t * @returns a lib/Deferred that can be used to resolve the test\n\t */\n\tasync(timeout?: number, numCallsUntilResolution?: number): Deferred<any> {\n\t\tthis._isAsync = true;\n\n\t\tif (timeout != null) {\n\t\t\tthis.timeout = timeout;\n\t\t}\n\n\t\tlet remainingCalls = numCallsUntilResolution || 1;\n\t\tconst dfd = new Deferred();\n\t\tconst oldResolve = dfd.resolve;\n\n\t\t/**\n\t\t * Eventually resolves the deferred, once `resolve` has been called as\n\t\t * many times as specified by the `numCallsUntilResolution` parameter of\n\t\t * the original `async` call.\n\t\t */\n\t\tdfd.resolve = function(this: any) {\n\t\t\t--remainingCalls;\n\t\t\tif (remainingCalls === 0) {\n\t\t\t\toldResolve.apply(this, arguments);\n\t\t\t} else if (remainingCalls < 0) {\n\t\t\t\tthrow new Error('resolve called too many times');\n\t\t\t}\n\t\t};\n\n\t\t// A test may call this function multiple times and should always get\n\t\t// the same Deferred\n\t\tthis.async = function() {\n\t\t\treturn dfd;\n\t\t};\n\n\t\treturn dfd;\n\t}\n\n\t/**\n\t * During an asynchronous test run, restarts the timeout timer.\n\t */\n\trestartTimeout(timeout?: number) {\n\t\tif (timeout != null) {\n\t\t\tthis.timeout = timeout;\n\t\t}\n\n\t\tif (this._runTask) {\n\t\t\tif (this._timer) {\n\t\t\t\tclearTimeout(this._timer);\n\t\t\t}\n\t\t\tthis._timer = setTimeout(() => {\n\t\t\t\tthis._timer = undefined;\n\t\t\t\tif (this._runTask) {\n\t\t\t\t\tconst error = new Error(`Timeout reached on ${this.id}#`);\n\t\t\t\t\terror.name = 'TimeoutError';\n\t\t\t\t\tthis.error = error;\n\t\t\t\t\tthis._runTask.cancel();\n\t\t\t\t}\n\t\t\t}, this.timeout);\n\t\t}\n\t}\n\n\t/**\n\t * Runs the test.\n\t */\n\trun() {\n\t\tlet startTime: number;\n\n\t\t// Cancel any currently running test\n\t\tif (this._runTask && this._runTask.state === State.Pending) {\n\t\t\tthis._runTask.cancel();\n\t\t\tthis._runTask = undefined;\n\t\t}\n\n\t\tif (this._timer) {\n\t\t\tclearTimeout(this._timer);\n\t\t\tthis._timer = undefined;\n\t\t}\n\n\t\t// Reset some state in case someone tries to re-run the same test\n\t\tthis._usesRemote = false;\n\t\tthis._hasPassed = false;\n\t\tthis._isAsync = false;\n\t\tthis._timeElapsed = 0;\n\t\tthis._runTask = undefined;\n\t\tthis.async = Object.getPrototypeOf(this).async;\n\t\tthis.error = undefined;\n\t\tthis.skipped = undefined;\n\n\t\treturn this.executor\n\t\t\t.emit('testStart', this)\n\t\t\t.then(() => {\n\t\t\t\tstartTime = Date.now();\n\t\t\t})\n\t\t\t.then<void>(() => {\n\t\t\t\tlet result: PromiseLike<any> | void = this.test(this);\n\n\t\t\t\t// Someone called `this.async`, so this test is async; we have\n\t\t\t\t// to prefer one or the other, so prefer the promise returned\n\t\t\t\t// from the test function if it exists, otherwise get the one\n\t\t\t\t// that was generated by `Test#async`\n\t\t\t\tif (this.isAsync) {\n\t\t\t\t\tif (!isThenable(result)) {\n\t\t\t\t\t\tresult = this.async().promise;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the user called this.async and returned a\n\t\t\t\t\t\t// thenable, wait for the first one to resolve or\n\t\t\t\t\t\t// reject.\n\t\t\t\t\t\tresult = Task.race([this.async().promise, result]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\t// Even if a user did not call `this.async`, we still mark\n\t\t\t\t\t// this test as asynchronous if a promise was returned\n\t\t\t\t\tthis._isAsync = true;\n\n\t\t\t\t\t// Wrap the runTask in another Task so that a canceled test\n\t\t\t\t\t// can be treated like a skip.\n\t\t\t\t\treturn new Task((resolve, reject) => {\n\t\t\t\t\t\tthis._runTask = new Task(\n\t\t\t\t\t\t\t(resolve, reject) => {\n\t\t\t\t\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\t\t\t\t\tresult.then(() => {\n\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t}, reject);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Most promise implementations that allow\n\t\t\t\t\t\t\t\t// cancellation don't signal that a promise was\n\t\t\t\t\t\t\t\t// canceled. In order to ensure that a timed out\n\t\t\t\t\t\t\t\t// test is never accidentally resolved, reject a\n\t\t\t\t\t\t\t\t// canceled test, treating it as a skipped test.\n\t\t\t\t\t\t\t\tif (isTask(result)) {\n\t\t\t\t\t\t\t\t\tconst resultTask = result;\n\t\t\t\t\t\t\t\t\tresultTask\n\t\t\t\t\t\t\t\t\t\t// Reject with SKIP in case we got here\n\t\t\t\t\t\t\t\t\t\t// before the promise resolved\n\t\t\t\t\t\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\tresultTask.state ===\n\t\t\t\t\t\t\t\t\t\t\t\tState.Canceled\n\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.skipped = 'Canceled';\n\t\t\t\t\t\t\t\t\t\t\t\treject(SKIP);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t// If the result rejected, consume the\n\t\t\t\t\t\t\t\t\t\t// error; it's handled above\n\t\t\t\t\t\t\t\t\t\t.catch(_error => {});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t// Only cancel the result if it's actually a\n\t\t\t\t\t\t\t\t// Task\n\t\t\t\t\t\t\t\tif (isTask(result)) {\n\t\t\t\t\t\t\t\t\tresult.cancel();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// If the test task was canceled between the\n\t\t\t\t\t\t\t\t// time it failed and the time it resolved,\n\t\t\t\t\t\t\t\t// reject it\n\t\t\t\t\t\t\t\tif (this.error) {\n\t\t\t\t\t\t\t\t\treject(this.error);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t).then(() => {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}, reject);\n\n\t\t\t\t\t\tthis.restartTimeout();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})\n\t\t\t.finally(() => {\n\t\t\t\t// If we got here but the test task hasn't finished, the test\n\t\t\t\t// was canceled\n\t\t\t\tif (this._runTask && this._runTask.state === State.Pending) {\n\t\t\t\t\tthis._runTask.cancel();\n\t\t\t\t}\n\n\t\t\t\tthis._runTask = undefined;\n\t\t\t\tthis._timeElapsed = Date.now() - startTime;\n\n\t\t\t\t// Ensure the timeout timer is cleared so the testing process\n\t\t\t\t// doesn't hang at exit\n\t\t\t\tif (this._timer) {\n\t\t\t\t\tclearTimeout(this._timer);\n\t\t\t\t\tthis._timer = undefined;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(() => {\n\t\t\t\t// Test completed successfully -- potentially passed\n\t\t\t\tif (this._usesRemote && !this.isAsync) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Remote used in synchronous test! Tests using this.remote must ' +\n\t\t\t\t\t\t\t'return a promise or resolve a this.async deferred.'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tthis._hasPassed = true;\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\t// There was an error running the test; could be a skip, could\n\t\t\t\t// be an assertion failure\n\t\t\t\tif (error !== SKIP) {\n\t\t\t\t\tthis.error = error;\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.finally(() => this.executor.emit('testEnd', this));\n\t}\n\n\t/**\n\t * Skips this test.\n\t *\n\t * Calling this function will cause a test to halt immediately. If a message\n\t * was provided, a reporter may report the test as skipped. Skipped tests\n\t * are not treated as passing or failing.\n\t *\n\t * @param message If provided, will be stored in this test's `skipped`\n\t * property.\n\t */\n\tskip(message: string = 'skipped') {\n\t\tthis.skipped = message;\n\t\tthrow SKIP;\n\t}\n\n\t/**\n\t * Return a JSON-representation of this test\n\t */\n\ttoJSON() {\n\t\tconst json: { [key: string]: any } = {};\n\t\tconst properties: (keyof Test)[] = [\n\t\t\t'id',\n\t\t\t'parentId',\n\t\t\t'name',\n\t\t\t'sessionId',\n\t\t\t'timeElapsed',\n\t\t\t'timeout',\n\t\t\t'hasPassed',\n\t\t\t'skipped'\n\t\t];\n\n\t\tproperties.forEach(key => {\n\t\t\tconst value = this[key];\n\t\t\tif (typeof value !== 'undefined') {\n\t\t\t\tjson[key] = value;\n\t\t\t}\n\t\t});\n\n\t\tif (this.error) {\n\t\t\tjson.error = {\n\t\t\t\tname: this.error.name,\n\t\t\t\tmessage: this.error.message,\n\t\t\t\tstack: this.error.stack,\n\t\t\t\tshowDiff: Boolean(this.error.showDiff)\n\t\t\t};\n\n\t\t\tif (this.error.showDiff) {\n\t\t\t\tjson.error.actual = this.error.actual;\n\t\t\t\tjson.error.expected = this.error.expected;\n\t\t\t}\n\t\t}\n\n\t\treturn json;\n\t}\n}\n\nexport function isTest(value: any): value is Test {\n\treturn (\n\t\tvalue != null &&\n\t\ttypeof value.test === 'function' &&\n\t\ttypeof value.hasPassed === 'boolean'\n\t);\n}\n\nexport function isTestOptions(value: any): value is TestOptions {\n\treturn (\n\t\tvalue != null &&\n\t\t!(value instanceof Test) &&\n\t\tvalue.name != null &&\n\t\tvalue.test != null\n\t);\n}\n\nexport interface TestFunction {\n\t(this: Test, test: Test): void | PromiseLike<any>;\n}\n\nexport function isTestFunction(value: any): value is TestFunction {\n\treturn typeof value === 'function';\n}\n\nexport interface TestProperties {\n\thasPassed: boolean;\n\tname: string;\n\tparent: Suite;\n\tskipped: string | undefined;\n\ttest: TestFunction;\n\ttimeout: number;\n}\n\nexport type TestOptions = Partial<TestProperties> & {\n\tname: string;\n\ttest: TestFunction;\n};\n\nexport const SKIP: any = {};\n"]}