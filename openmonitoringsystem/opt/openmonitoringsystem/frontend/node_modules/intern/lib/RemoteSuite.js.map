{"version":3,"file":"RemoteSuite.js","sourceRoot":"","sources":["../../../src/lib/RemoteSuite.ts"],"names":[],"mappings":"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","sourcesContent":["import { parse } from 'url';\nimport { relative } from 'path';\nimport UrlSearchParams from '@dojo/core/UrlSearchParams';\nimport { Handle, Hash } from '@dojo/core/interfaces';\nimport Task from '@dojo/core/async/Task';\n\nimport Suite, { SuiteOptions } from './Suite';\nimport { InternError } from './types';\nimport Node, { NodeEvents } from './executors/Node';\nimport { Config } from './common/config';\nimport Browser from './executors/Browser';\nimport { stringify } from './common/util';\nimport Deferred from './Deferred';\n\n// This is used for the `execute` config block\ndeclare const intern: Browser;\n\n/**\n * RemoteSuite is a class that acts as a local server for one or more unit test\n * suites being run in a remote browser.\n */\nexport default class RemoteSuite extends Suite {\n\texecutor!: Node;\n\n\tconstructor(options?: Partial<SuiteOptions>) {\n\t\toptions = options || {};\n\t\tif (options.name == null) {\n\t\t\toptions.name = 'remote unit tests';\n\t\t}\n\n\t\tsuper(<SuiteOptions>options);\n\n\t\tif (this.timeout == null) {\n\t\t\tthis.timeout = Infinity;\n\t\t}\n\t}\n\n\t/**\n\t * Override Suite#id to exclude the RemoteSuite's name from the generated ID\n\t * since the RemoteSuite is just a proxy for a remote suite.\n\t */\n\tget id() {\n\t\tlet name: string[] = [];\n\t\tlet suite: Suite = this.parent!;\n\n\t\tdo {\n\t\t\tsuite.name != null && name.unshift(suite.name);\n\t\t} while ((suite = suite.parent!));\n\n\t\treturn name.join(' - ');\n\t}\n\n\t/**\n\t * Run a suite in a remote browser.\n\t */\n\trun(): Task<any> {\n\t\tconst remote = this.remote;\n\t\tconst sessionId = remote.session.sessionId;\n\t\tconst server = this.executor.server!;\n\t\tlet listenerHandle: Handle;\n\t\tlet connectTimer: NodeJS.Timer;\n\n\t\treturn new Task(\n\t\t\t(resolve, reject) => {\n\t\t\t\tconst handleError = (error: InternError) => {\n\t\t\t\t\tthis.error = error;\n\t\t\t\t\treject(error);\n\t\t\t\t};\n\n\t\t\t\tconst config = this.executor.config;\n\n\t\t\t\t// This is a deferred that will resolve when the remote sends\n\t\t\t\t// back a 'remoteConfigured' message\n\t\t\t\tconst pendingConnection = new Deferred<void>();\n\n\t\t\t\t// If the remote takes to long to connect, reject the connection\n\t\t\t\t// promise\n\t\t\t\tconst connectTimeout = config.connectTimeout;\n\t\t\t\tconnectTimer = global.setTimeout(() => {\n\t\t\t\t\tconst error = new Error(\n\t\t\t\t\t\t'Timed out waiting for remote to connect'\n\t\t\t\t\t);\n\t\t\t\t\terror.name = 'TimeoutError';\n\t\t\t\t\tpendingConnection.reject(error);\n\t\t\t\t}, connectTimeout);\n\n\t\t\t\t// Subscribe to messages received by the server for a particular\n\t\t\t\t// remote session ID.\n\t\t\t\tlistenerHandle = server.subscribe(\n\t\t\t\t\tsessionId,\n\t\t\t\t\t(eventName: string, data: any) => {\n\t\t\t\t\t\tconst name = <keyof RemoteEvents>eventName;\n\t\t\t\t\t\tlet suite: Suite;\n\n\t\t\t\t\t\tswitch (name) {\n\t\t\t\t\t\t\tcase 'remoteStatus':\n\t\t\t\t\t\t\t\tif (data === 'initialized') {\n\t\t\t\t\t\t\t\t\tclearTimeout(connectTimer);\n\t\t\t\t\t\t\t\t\tpendingConnection.resolve();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'suiteStart':\n\t\t\t\t\t\t\t\tsuite = data;\n\t\t\t\t\t\t\t\tif (!suite.hasParent) {\n\t\t\t\t\t\t\t\t\t// This suite from the browser is a root\n\t\t\t\t\t\t\t\t\t// suite; add its tests to the local suite\n\t\t\t\t\t\t\t\t\tthis.tests.push(...suite.tests);\n\n\t\t\t\t\t\t\t\t\t// Tell the executor that the local suite\n\t\t\t\t\t\t\t\t\t// has started\n\t\t\t\t\t\t\t\t\treturn this.executor.emit(\n\t\t\t\t\t\t\t\t\t\t'suiteStart',\n\t\t\t\t\t\t\t\t\t\tthis\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// If suite from the browser isn't a root\n\t\t\t\t\t\t\t\t\t// (i.e., it's a nested suite), just forward\n\t\t\t\t\t\t\t\t\t// the start event\n\t\t\t\t\t\t\t\t\treturn this.executor.emit(name, data);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcase 'suiteEnd':\n\t\t\t\t\t\t\t\tsuite = data;\n\t\t\t\t\t\t\t\tthis.skipped = suite.skipped;\n\n\t\t\t\t\t\t\t\tif (!suite.hasParent) {\n\t\t\t\t\t\t\t\t\t// When the remote root suite has finished,\n\t\t\t\t\t\t\t\t\t// replace the local test objects with the\n\t\t\t\t\t\t\t\t\t// incoming test data since it will include\n\t\t\t\t\t\t\t\t\t// final results.\n\t\t\t\t\t\t\t\t\tsuite.tests.forEach((test, index) => {\n\t\t\t\t\t\t\t\t\t\tthis.tests[index] = test;\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tif (suite.error) {\n\t\t\t\t\t\t\t\t\t\thandleError(suite.error);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// If suite from the browser isn't a root,\n\t\t\t\t\t\t\t\t\t// just forward the end event\n\t\t\t\t\t\t\t\t\treturn this.executor.emit(name, data);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'beforeRun':\n\t\t\t\t\t\t\tcase 'afterRun':\n\t\t\t\t\t\t\tcase 'runStart':\n\t\t\t\t\t\t\t\t// Consume these events -- they shouldn't be\n\t\t\t\t\t\t\t\t// forwarded to any local listeners\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'runEnd':\n\t\t\t\t\t\t\t\t// Consume this event, and do some\n\t\t\t\t\t\t\t\t// post-processing\n\t\t\t\t\t\t\t\tlet promise = remote.setHeartbeatInterval(0);\n\t\t\t\t\t\t\t\tif (this.executor.hasCoveredFiles) {\n\t\t\t\t\t\t\t\t\t// get about:blank to always collect code\n\t\t\t\t\t\t\t\t\t// coverage data from the page in case it is\n\t\t\t\t\t\t\t\t\t// navigated away later by some other\n\t\t\t\t\t\t\t\t\t// process; this happens during self-testing\n\t\t\t\t\t\t\t\t\t// when the Leadfoot library takes over\n\t\t\t\t\t\t\t\t\tpromise = promise.get('about:blank');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn promise.then(resolve, reject);\n\n\t\t\t\t\t\t\tcase 'error':\n\t\t\t\t\t\t\t\t// Ignore summary suite error messages\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t!/One or more suite errors/.test(\n\t\t\t\t\t\t\t\t\t\tdata.message\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\thandleError(data);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn this.executor.emit(name, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tconst serverUrl = parse(config.serverUrl);\n\n\t\t\t\t// Intern runs unit tests on the remote Selenium server by\n\t\t\t\t// navigating to the client runner HTML page. No real commands\n\t\t\t\t// are issued after the call to remote.get() below until all\n\t\t\t\t// unit tests are complete, so we need to make sure that we\n\t\t\t\t// periodically send no-ops through the channel to ensure the\n\t\t\t\t// remote server does not treat the session as having timed out\n\t\t\t\tconst timeout = config.heartbeatInterval!;\n\t\t\t\tif (timeout >= 1 && timeout < Infinity) {\n\t\t\t\t\tremote.setHeartbeatInterval((timeout - 1) * 1000);\n\t\t\t\t}\n\n\t\t\t\t// These are options that will be passed as query params to the\n\t\t\t\t// test harness page\n\t\t\t\tconst queryOptions: Partial<RemoteConfig> = {\n\t\t\t\t\tbasePath: serverUrl.pathname,\n\t\t\t\t\trunInSync: config.runInSync || false,\n\t\t\t\t\tserverUrl: serverUrl.href,\n\t\t\t\t\tsessionId: sessionId,\n\t\t\t\t\tsocketPort: server.socketPort\n\t\t\t\t};\n\n\t\t\t\t// Do some pre-serialization of the options\n\t\t\t\tconst queryParams: Hash<any> = {};\n\t\t\t\tObject.keys(queryOptions)\n\t\t\t\t\t.filter(option => {\n\t\t\t\t\t\tconst key = <keyof RemoteConfig>option;\n\t\t\t\t\t\treturn queryOptions[key] != null;\n\t\t\t\t\t})\n\t\t\t\t\t.forEach(option => {\n\t\t\t\t\t\tconst key = <keyof RemoteConfig>option;\n\t\t\t\t\t\tlet value = queryOptions[key];\n\t\t\t\t\t\tif (typeof value === 'object') {\n\t\t\t\t\t\t\tvalue = JSON.stringify(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqueryParams[key] = value;\n\t\t\t\t\t});\n\n\t\t\t\tconst query = new UrlSearchParams(queryParams);\n\t\t\t\tconst harness = `${\n\t\t\t\t\tconfig.serverUrl\n\t\t\t\t}__intern/browser/remote.html`;\n\n\t\t\t\t// Determine the relative path from basePath to internPath. This\n\t\t\t\t// will be used to derive the internPath sent to the remote. The\n\t\t\t\t// remote will figure out its own basePath.\n\t\t\t\tconst internPath = relative(config.basePath, config.internPath);\n\n\t\t\t\t// These are options that will be POSTed to the remote page and\n\t\t\t\t// used to configure intern. Stringify and parse them to ensure\n\t\t\t\t// that the config can be properly transmitted.\n\t\t\t\tconst remoteConfig: Partial<RemoteConfig> = {\n\t\t\t\t\tdebug: config.debug,\n\t\t\t\t\tinternPath: `${serverUrl.pathname}${internPath}`,\n\t\t\t\t\tname: this.id,\n\t\t\t\t\treporters: [{ name: 'dom' }]\n\t\t\t\t};\n\n\t\t\t\t// Don't overwrite any config data we've already set\n\t\t\t\tconst excludeKeys: { [key: string]: boolean } = {\n\t\t\t\t\tbasePath: true,\n\t\t\t\t\tinternPath: true,\n\t\t\t\t\tname: true,\n\t\t\t\t\treporters: true,\n\t\t\t\t\tserverUrl: true,\n\t\t\t\t\tsessionId: true,\n\t\t\t\t\tsocketPort: true\n\t\t\t\t};\n\n\t\t\t\t// Pass all non-excluded keys to the remote config\n\t\t\t\tObject.keys(config)\n\t\t\t\t\t.filter(key => !excludeKeys[key])\n\t\t\t\t\t.forEach(property => {\n\t\t\t\t\t\tconst key = <keyof RemoteConfig>property;\n\t\t\t\t\t\tremoteConfig[key] = config[key];\n\t\t\t\t\t});\n\n\t\t\t\tthis.executor.log(\n\t\t\t\t\t'Configuring remote \"',\n\t\t\t\t\tthis.name,\n\t\t\t\t\t'\" with',\n\t\t\t\t\tremoteConfig\n\t\t\t\t);\n\n\t\t\t\tremote\n\t\t\t\t\t.get(`${harness}?${query}`)\n\t\t\t\t\t.then(() => pendingConnection.promise)\n\t\t\t\t\t// Send the config data in an execute block to avoid sending\n\t\t\t\t\t// very large query strings\n\t\t\t\t\t.execute(\n\t\t\t\t\t\t/* istanbul ignore next */ function(\n\t\t\t\t\t\t\tconfigString: string\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst options = JSON.parse(configString);\n\t\t\t\t\t\t\tintern.configure(options);\n\t\t\t\t\t\t\tintern.run().catch(_error => {});\n\t\t\t\t\t\t},\n\t\t\t\t\t\t[stringify(remoteConfig)]\n\t\t\t\t\t)\n\t\t\t\t\t// If there's an error loading the page, kill the heartbeat\n\t\t\t\t\t// and fail\n\t\t\t\t\t.catch(error =>\n\t\t\t\t\t\tremote\n\t\t\t\t\t\t\t.setHeartbeatInterval(0)\n\t\t\t\t\t\t\t.finally(() => handleError(error))\n\t\t\t\t\t);\n\t\t\t},\n\t\t\t// Canceller\n\t\t\t() => remote.setHeartbeatInterval(0)\n\t\t)\n\t\t\t.catch(error => {\n\t\t\t\tif (!this.error) {\n\t\t\t\t\tthis.error = error;\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t})\n\t\t\t.finally(() => {\n\t\t\t\tif (connectTimer) {\n\t\t\t\t\tclearTimeout(connectTimer);\n\t\t\t\t}\n\t\t\t\tlistenerHandle.destroy();\n\t\t\t})\n\t\t\t.finally(() => this.executor.emit('suiteEnd', this));\n\t}\n}\n\nexport interface RemoteEvents extends NodeEvents {\n\tremoteStatus: string;\n}\n\nexport interface RemoteConfig extends Config {\n\tserverUrl: string;\n\tsessionId: string;\n\trunInSync: boolean;\n\tsocketPort?: number;\n}\n"]}