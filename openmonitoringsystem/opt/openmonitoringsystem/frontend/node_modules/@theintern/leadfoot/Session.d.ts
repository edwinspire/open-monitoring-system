/// <reference types="node" />
import Element from './Element';
import Server from './Server';
import Task from '@dojo/core/async/Task';
import statusCodes from './lib/statusCodes';
import Locator, { Strategy } from './lib/Locator';
import { Capabilities, Geolocation, LogEntry, WebDriverCookie } from './interfaces';
export default class Session extends Locator<Task<Element>, Task<Element[]>, Task<void>> {
    private _sessionId;
    private _server;
    private _capabilities;
    private _closedWindows;
    private _timeouts;
    private _movedToElement;
    private _lastMousePosition;
    private _lastAltitude;
    private _nextRequest;
    constructor(sessionId: string, server: Server, capabilities: Capabilities);
    readonly capabilities: Capabilities;
    readonly sessionId: string;
    readonly server: Server;
    private _delegateToServer<T>(method, path, requestData, pathParts?);
    serverGet<T>(path: string, requestData?: any, pathParts?: string[]): Task<T>;
    serverPost<T>(path: string, requestData?: any, pathParts?: string[]): Task<T>;
    serverDelete<T>(path: string, requestData?: any, pathParts?: string[]): Task<T>;
    getTimeout(type: Timeout): Task<number>;
    setTimeout(type: Timeout, ms: number): Task<void>;
    getCurrentWindowHandle(): Task<string>;
    getAllWindowHandles(): Task<string[]>;
    getCurrentUrl(): Task<string>;
    get(url: string): Task<void>;
    goForward(): Task<void>;
    goBack(): Task<void>;
    refresh(): Task<void>;
    execute<T>(script: Function | string, args?: any[]): Task<T>;
    executeAsync<T>(script: Function | string, args?: any[]): Task<any>;
    takeScreenshot(): Task<Buffer>;
    getAvailableImeEngines(): Task<string[]>;
    getActiveImeEngine(): Task<string>;
    isImeActivated(): Task<boolean>;
    deactivateIme(): Task<void>;
    activateIme(engine: string): Task<void>;
    switchToFrame(id: string | number | Element): Task<void>;
    switchToWindow(handle: string): Task<void>;
    switchToParentFrame(): Task<void>;
    closeCurrentWindow(): Task<void>;
    setWindowSize(width: number, height: number): Task<void>;
    setWindowSize(windowHandle: string, width: number, height: number): Task<void>;
    getWindowSize(windowHandle?: string): Task<{
        width: number;
        height: number;
    }>;
    getWindowRect(): Task<{
        width: number;
        height: number;
        x: number;
        y: number;
    }>;
    setWindowRect(rect: {
        x: number;
        y: number;
        width: number;
        height: number;
    }): Task<void>;
    setWindowPosition(x: number, y: number): Task<void>;
    setWindowPosition(windowHandle: string, x: number, y: number): Task<void>;
    getWindowPosition(windowHandle?: string): Task<{
        x: number;
        y: number;
    }>;
    maximizeWindow(windowHandle?: string): Task<void>;
    getCookies(): Task<any[]>;
    setCookie(cookie: WebDriverCookie): Task<void>;
    clearCookies(): Task<any>;
    deleteCookie(name: string): Task<void>;
    getPageSource(): Task<string>;
    getPageTitle(): Task<string>;
    find(using: Strategy, value: string): Task<Element>;
    findAll(using: Strategy, value: string): Task<Element[]>;
    getActiveElement(): Task<Element>;
    pressKeys(keys: string | string[]): Task<{}> | Task<void>;
    getOrientation(): Task<string>;
    setOrientation(orientation: string): Task<void>;
    getAlertText(): Task<string>;
    typeInPrompt(text: string | string[]): Task<void>;
    acceptAlert(): Task<void>;
    dismissAlert(): Task<void>;
    moveMouseTo(): Task<void>;
    moveMouseTo(xOffset?: number, yOffset?: number): Task<void>;
    moveMouseTo(element?: Element, xOffset?: number, yOffset?: number): Task<void>;
    clickMouseButton(button?: number): Task<void>;
    pressMouseButton(button?: number): Task<void>;
    releaseMouseButton(button?: number): Task<void>;
    doubleClick(): Task<void>;
    tap(element: Element): Task<void>;
    pressFinger(x: number, y: number): Task<void>;
    releaseFinger(x: number, y: number): Task<void>;
    moveFinger(x: number, y: number): Task<void>;
    touchScroll(xOffset: number, yOffset: number): Task<void>;
    touchScroll(element?: Element, xOffset?: number, yOffset?: number): Task<void>;
    doubleTap(element?: Element): Task<void>;
    longTap(element?: Element): Task<void>;
    flickFinger(element: Element, xOffset: number, yOffset: number, speed?: number): Task<void>;
    flickFinger(xOffset: number, yOffset: number, speed?: number): Task<void>;
    getGeolocation(): Task<Geolocation>;
    setGeolocation(location: Geolocation): Task<void>;
    getLogsFor(type: string): Task<LogEntry[]>;
    getAvailableLogTypes(): Task<string[]>;
    getApplicationCacheStatus(): Task<number>;
    quit(): Task<void>;
    private _manualFindByLinkText(using, value, multiple, element?);
    getLocalStorageKeys(): Task<string[]>;
    setLocalStorageItem(key: string, value: string): Task<void>;
    clearLocalStorage(): Task<void>;
    getLocalStorageItem(key: string): Task<string>;
    deleteLocalStorageItem(key: string): Task<void>;
    getLocalStorageLength(): Task<number>;
    getSessionStorageKeys(): Task<string[]>;
    setSessionStorageItem(key: string, value: string): Task<void>;
    clearSessionStorage(): Task<void>;
    getSessionStorageItem(key: string): Task<string>;
    deleteSessionStorageItem(key: string): Task<void>;
    getSessionStorageLength(): Task<number>;
    findDisplayed(using: Strategy, value: string): Task<Element>;
    waitForDeleted(using: Strategy, value: string): Task<void>;
    getExecuteAsyncTimeout(): Task<number>;
    setExecuteAsyncTimeout(ms: number): Task<void>;
    getFindTimeout(): Task<number>;
    setFindTimeout(ms: number): Task<void>;
    getPageLoadTimeout(): Task<number>;
    setPageLoadTimeout(ms: number): Task<void>;
}
export interface SessionError extends Error {
    status?: keyof typeof statusCodes;
}
export declare type Timeout = 'script' | 'implicit' | 'page load';
