{"version":3,"file":"pollUntil.js","sourceRoot":"","sources":["../../../src/helpers/pollUntil.ts"],"names":[],"mappings":";;AAAA,kCAAoC;AA6EpC,mBACC,MAAuB,EACvB,aAA8B,EAC9B,OAAgB,EAChB,YAAqB;IAErB,IAAI,IAAuB,CAAC;IAE5B,IAAI,OAAO,aAAa,KAAK,QAAQ,EAAE;QACtC,YAAY,GAAG,OAAO,CAAC;QACvB,OAAO,GAAG,aAAa,CAAC;KACxB;SAAM;QACN,IAAI,GAAG,aAAa,CAAC;KACrB;IAED,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC;IAClB,YAAY,GAAG,YAAY,IAAI,EAAE,CAAC;IAElC,OAAO;QACN,IAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAC7B,IAAI,eAAuB,CAAC;QAE5B,OAAO,OAAO,CAAC,sBAAsB,EAAE,CAAC,IAAI,CAAC,UAAS,cAAc;YACnE,IAAI,aAAwB,CAAC;YAE7B,qBAAqB,MAAW;gBAC/B,aAAa,GAAG,MAAM,CAAC;YACxB,CAAC;YAED;gBACC,IAAI,aAAa,YAAY,KAAK,EAAE;oBACnC,MAAM,aAAa,CAAC;iBACpB;gBACD,IAAI,aAAa,IAAI,IAAI,EAAE;oBAC1B,IAAM,KAAK,GAAG,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;oBAC5D,KAAK,CAAC,IAAI,GAAG,eAAe,CAAC;oBAC7B,MAAM,KAAK,CAAC;iBACZ;gBACD,OAAO,aAAa,CAAC;YACtB,CAAC;YAED;gBACC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,EAAE;oBAC5B,OAAO,OAAO;yBACZ,sBAAsB,CAAC,eAAe,CAAC;yBACvC,IAAI,CAAC,MAAM,CAAC,CAAC;iBACf;gBACD,OAAO,MAAM,EAAE,CAAC;YACjB,CAAC;YAED,IAAI,CAAC,KAAK,CAAS,OAAO,CAAC,EAAE;gBAC5B,eAAe,GAAG,cAAc,CAAC;aACjC;iBAAM;gBACN,OAAO,GAAG,cAAc,CAAC;aACzB;YAED,OAAO,OAAO;iBACZ,sBAAsB,CAAC,OAAQ,CAAC;iBAChC,IAAI,CAAC;gBAEL,OAAO,OAAO,CAAC,YAAY,CACC,UAC1B,MAAyB,EACzB,IAAW,EACX,OAAe,EACf,YAAoB,EACpB,IAAc;oBAGd,MAAM,GAAa,IAAI,QAAQ,CAAS,MAAM,CAAC,CAAC;oBAEhD,IAAM,OAAO,GAAG,MAAM,CAAC,IAAI,IAAI,EAAE,CAAC,GAAG,OAAO,CAAC;oBAE7C,CAAC;wBACA,IAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;wBAGxC,IAAI,MAAM,IAAI,IAAI,EAAE;4BACnB,IAAI,CAAC,MAAM,CAAC,CAAC;yBACb;6BAAM,IAAI,MAAM,CAAC,IAAI,IAAI,EAAE,CAAC,GAAG,OAAO,EAAE;4BACxC,UAAU,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;yBAC/B;6BAAM;4BACN,IAAI,CAAC,IAAI,CAAC,CAAC;yBACX;oBACF,CAAC,CAAC,EAAE,CAAC;gBACN,CAAC,EACD;oBACC,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC;oBAC5B,IAAI;oBACJ,OAAO;oBACP,YAAY;iBACZ,CACD,CAAC;YACH,CAAC,CAAC;iBACD,IAAI,CAAC,WAAW,EAAE,WAAW,CAAC;iBAC9B,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QAC1B,CAAC,CAAC,CAAC;IACJ,CAAC,CAAC;AACH,CAAC;AAlGD,4BAkGC","sourcesContent":["import * as util from '../lib/util';\nimport Command from '../Command';\nimport Task from '@dojo/core/async/Task';\n\n/**\n * A [[Command]] helper that polls for a value within the client environment\n * until the value exists or a timeout is reached.\n *\n * ```js\n * import Command from 'leadfoot/Command';\n * import pollUntil from 'leadfoot/helpers/pollUntil';\n *\n * new Command(session)\n *     .get('http://example.com')\n *     .then(pollUntil('return document.getElementById(\"a\");', 1000))\n *     .then(\n *         elementA => {\n *             // element was found\n *         },\n *         error => {\n *             // element was not found\n *         }\n *     );\n * ```\n *\n * ```js\n * import Command from 'leadfoot/Command';\n * import pollUntil from 'leadfoot/helpers/pollUntil';\n *\n * new Command(session)\n *     .get('http://example.com')\n *     .then(pollUntil(value => {\n *         const element = document.getElementById('a');\n *         return element && element.value === value ? true : null;\n *     }, [ 'foo' ], 1000))\n *     .then(\n *         () => {\n *             // value was set to 'foo'\n *         },\n *         error => {\n *             // value was never set\n *         }\n *     );\n * ```\n *\n * @param poller The poller function to execute on an interval. The function\n * should return `null` or `undefined` if there is not a result. If the poller\n * function throws, polling will halt.\n *\n * @param args An array of arguments to pass to the poller function when it is\n * invoked. Only values that can be serialised to JSON, plus [[Element]]\n * objects, can be specified as arguments.\n *\n * @param timeout The maximum amount of time to wait for a successful result,\n * in milliseconds. If not specified, the current `executeAsync` maximum\n * timeout for the session will be used.\n *\n * @param pollInterval The amount of time to wait between calls to the poller\n * function, in milliseconds. If not specified, defaults to 67ms.\n *\n * @returns A [[Command]] callback function that, when called, returns a\n * promise that resolves to the value returned by the poller function on\n * success and rejects on failure.\n */\nexport default function pollUntil<T>(\n\tpoller: Poller | string,\n\targs?: any[],\n\ttimeout?: number,\n\tpollInterval?: number\n): () => Task<T>;\n\nexport default function pollUntil<T>(\n\tpoller: Poller | string,\n\ttimeout?: number,\n\tpollInterval?: number\n): () => Task<T>;\n\nexport default function pollUntil<T>(\n\tpoller: Poller | string,\n\targsOrTimeout?: any[] | number,\n\ttimeout?: number,\n\tpollInterval?: number\n): () => Task<T> {\n\tlet args: any[] | undefined;\n\n\tif (typeof argsOrTimeout === 'number') {\n\t\tpollInterval = timeout;\n\t\ttimeout = argsOrTimeout;\n\t} else {\n\t\targs = argsOrTimeout;\n\t}\n\n\targs = args || [];\n\tpollInterval = pollInterval || 67;\n\n\treturn function(this: Command<any>) {\n\t\tconst session = this.session;\n\t\tlet originalTimeout: number;\n\n\t\treturn session.getExecuteAsyncTimeout().then(function(currentTimeout) {\n\t\t\tlet resultOrError: T | Error;\n\n\t\t\tfunction storeResult(result: any) {\n\t\t\t\tresultOrError = result;\n\t\t\t}\n\n\t\t\tfunction finish() {\n\t\t\t\tif (resultOrError instanceof Error) {\n\t\t\t\t\tthrow resultOrError;\n\t\t\t\t}\n\t\t\t\tif (resultOrError == null) {\n\t\t\t\t\tconst error = new Error('Polling timed out with no result');\n\t\t\t\t\terror.name = 'ScriptTimeout';\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t\treturn resultOrError;\n\t\t\t}\n\n\t\t\tfunction cleanup() {\n\t\t\t\tif (!isNaN(originalTimeout)) {\n\t\t\t\t\treturn session\n\t\t\t\t\t\t.setExecuteAsyncTimeout(originalTimeout)\n\t\t\t\t\t\t.then(finish);\n\t\t\t\t}\n\t\t\t\treturn finish();\n\t\t\t}\n\n\t\t\tif (!isNaN(<number>timeout)) {\n\t\t\t\toriginalTimeout = currentTimeout;\n\t\t\t} else {\n\t\t\t\ttimeout = currentTimeout;\n\t\t\t}\n\n\t\t\treturn session\n\t\t\t\t.setExecuteAsyncTimeout(timeout!)\n\t\t\t\t.then(function() {\n\t\t\t\t\t/* jshint maxlen:140 */\n\t\t\t\t\treturn session.executeAsync(\n\t\t\t\t\t\t/* istanbul ignore next */ function(\n\t\t\t\t\t\t\tpoller: string | Function,\n\t\t\t\t\t\t\targs: any[],\n\t\t\t\t\t\t\ttimeout: number,\n\t\t\t\t\t\t\tpollInterval: number,\n\t\t\t\t\t\t\tdone: Function\n\t\t\t\t\t\t): void {\n\t\t\t\t\t\t\t/* jshint evil:true */\n\t\t\t\t\t\t\tpoller = <Function>new Function(<string>poller);\n\n\t\t\t\t\t\t\tconst endTime = Number(new Date()) + timeout;\n\n\t\t\t\t\t\t\t(function poll(this: any) {\n\t\t\t\t\t\t\t\tconst result = poller.apply(this, args);\n\n\t\t\t\t\t\t\t\t/*jshint evil:true */\n\t\t\t\t\t\t\t\tif (result != null) {\n\t\t\t\t\t\t\t\t\tdone(result);\n\t\t\t\t\t\t\t\t} else if (Number(new Date()) < endTime) {\n\t\t\t\t\t\t\t\t\tsetTimeout(poll, pollInterval);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdone(null);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})();\n\t\t\t\t\t\t},\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tutil.toExecuteString(poller),\n\t\t\t\t\t\t\targs,\n\t\t\t\t\t\t\ttimeout,\n\t\t\t\t\t\t\tpollInterval\n\t\t\t\t\t\t]\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t\t.then(storeResult, storeResult)\n\t\t\t\t.then(cleanup, cleanup);\n\t\t});\n\t};\n}\n\nexport type Poller = () => any;\n"]}