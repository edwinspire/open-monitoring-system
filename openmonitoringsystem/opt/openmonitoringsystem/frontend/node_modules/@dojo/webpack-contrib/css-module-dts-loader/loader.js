"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const typescript_1 = require("typescript");
const DtsCreator = require('typed-css-modules');
const { getOptions } = require('loader-utils');
const instances = require('ts-loader/dist/instances');
const creator = new DtsCreator();
const mTimeMap = new Map();
const cssMap = new Map();
function generateDTSFile(filePath, sourceFilesRegex) {
    return Promise.resolve().then(() => {
        if (!sourceFilesRegex.test(filePath)) {
            return;
        }
        const { mtime } = fs_1.statSync(filePath);
        const lastMTime = mTimeMap.get(filePath);
        if (!lastMTime || mtime > lastMTime) {
            const newCss = fs_1.existsSync(filePath) ? fs_1.readFileSync(filePath, 'utf-8') : '';
            const dtsFilePath = `${filePath}.d.ts`;
            const definition = fs_1.existsSync(dtsFilePath) ? fs_1.readFileSync(dtsFilePath, 'utf-8') : '';
            const css = cssMap.get(filePath) || '';
            mTimeMap.set(filePath, mtime);
            if (newCss !== css) {
                return creator.create(filePath, false, true).then((content) => {
                    cssMap.set(filePath, newCss);
                    const newDefinition = content.formatted;
                    if (newDefinition !== definition) {
                        return content.writeFile();
                    }
                });
            }
        }
    });
}
function getCssImport(node, loaderContext) {
    if (node.kind === typescript_1.SyntaxKind.StringLiteral) {
        const importPath = node.getText().replace(/\'|\"/g, '');
        if (/\.css$/.test(importPath)) {
            const parentFileName = node.getSourceFile().fileName;
            return new Promise((resolve, reject) => {
                loaderContext.resolve(path_1.dirname(parentFileName), importPath, (error, path) => {
                    if (error) {
                        reject(error);
                    }
                    if (!path) {
                        reject(new Error('Unable to resolve path to css file'));
                    }
                    resolve(path);
                });
            });
        }
    }
}
function traverseNode(node, filePaths, loaderContext) {
    switch (node.kind) {
        case typescript_1.SyntaxKind.SourceFile:
            typescript_1.forEachChild(node, (childNode) => {
                traverseNode(childNode, filePaths, loaderContext);
            });
            break;
        case typescript_1.SyntaxKind.ImportDeclaration:
            typescript_1.forEachChild(node, (childNode) => {
                const path = getCssImport(childNode, loaderContext);
                path && filePaths.push(path);
            });
            break;
    }
    return filePaths;
}
function default_1(content, sourceMap) {
    const callback = this.async();
    const { type = 'ts', instanceName, sourceFilesPattern = /src[\\\/]/ } = getOptions(this);
    const sourceFilesRegex = typeof sourceFilesPattern === 'string' ? new RegExp(sourceFilesPattern) : sourceFilesPattern;
    Promise.resolve()
        .then(() => {
        let generationPromises = [];
        switch (type) {
            case 'css':
                generationPromises.push(generateDTSFile(this.resourcePath, sourceFilesRegex));
                break;
            case 'ts':
                const sourceFile = typescript_1.createSourceFile(this.resourcePath, content, typescript_1.ScriptTarget.Latest, true);
                const cssFilePathPromises = traverseNode(sourceFile, [], this);
                if (cssFilePathPromises.length) {
                    if (instanceName) {
                        const instanceWrapper = instances.getTypeScriptInstance({ instance: instanceName });
                        if (instanceWrapper.instance) {
                            instanceWrapper.instance.files[this.resourcePath] = undefined;
                        }
                    }
                    generationPromises = cssFilePathPromises.map((cssFilePathPromise) => cssFilePathPromise.then((cssFilePath) => generateDTSFile(cssFilePath, sourceFilesRegex)));
                }
                break;
        }
        return Promise.all(generationPromises);
    })
        .then(() => callback(null, content, sourceMap), (error) => callback(error));
}
exports.default = default_1;
//# sourceMappingURL=loader.js.map